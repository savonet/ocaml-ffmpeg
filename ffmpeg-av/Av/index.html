<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Av (ffmpeg-av.Av)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">ffmpeg-av</a> &#x00BB; Av</nav><h1>Module <code>Av</code></h1><p>This module perform demuxing then decoding for reading and coding then muxing for writing multimedia container formats.</p><nav class="toc"><ul><li><a href="#format">Format</a></li><li><a href="#input">Input</a></li><li><a href="#output">Output</a></li></ul></nav></header><dl><dt class="spec value" id="val-container_options"><a href="#val-container_options" class="anchor"></a><code><span class="keyword">val</span> container_options : <a href="../../ffmpeg-avutil/Avutil/Options/index.html#type-t">Avutil.Options.t</a></code></dt></dl><section><header><h6 id="format"><a href="#format" class="anchor"></a>Format</h6></header><div class="spec module" id="module-Format"><a href="#module-Format" class="anchor"></a><code><span class="keyword">module</span> <a href="Format/index.html">Format</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h6 id="input"><a href="#input" class="anchor"></a>Input</h6></header><dl><dt class="spec value" id="val-open_input"><a href="#val-open_input" class="anchor"></a><code><span class="keyword">val</span> open_input : <span>?&#8288;format:<span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <span class="type-var">_</span>)</span> <a href="../../ffmpeg-avutil/Avutil/index.html#type-format">Avutil.format</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;opts:<a href="../../ffmpeg-avutil/Avutil/index.html#type-opts">Avutil.opts</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span></code></dt><dd><p><code>Av.open_input url</code> open the input <code>url</code> (a file name or http URL). After returning, if <code>opts</code> was passed, unused options are left in the hash table. Raise Error if the opening failed.</p></dd></dl><dl><dt class="spec type" id="type-read"><a href="#type-read" class="anchor"></a><code><span class="keyword">type</span> read</code><code> = bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec type" id="type-write"><a href="#type-write" class="anchor"></a><code><span class="keyword">type</span> write</code><code> = bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec type" id="type-seek"><a href="#type-seek" class="anchor"></a><code><span class="keyword">type</span> seek</code><code> = int <span>&#45;&gt;</span> Unix.seek_command <span>&#45;&gt;</span> int</code></dt></dl><dl><dt class="spec value" id="val-open_input_stream"><a href="#val-open_input_stream" class="anchor"></a><code><span class="keyword">val</span> open_input_stream : <span>?&#8288;format:<span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <span class="type-var">_</span>)</span> <a href="../../ffmpeg-avutil/Avutil/index.html#type-format">Avutil.format</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;opts:<a href="../../ffmpeg-avutil/Avutil/index.html#type-opts">Avutil.opts</a></span> <span>&#45;&gt;</span> <span>?&#8288;seek:<a href="index.html#type-seek">seek</a></span> <span>&#45;&gt;</span> <a href="index.html#type-read">read</a> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span></code></dt><dt class="spec value" id="val-get_input_duration"><a href="#val-get_input_duration" class="anchor"></a><code><span class="keyword">val</span> get_input_duration : <span>?&#8288;format:<a href="../../ffmpeg-avutil/Avutil/Time_format/index.html#type-t">Avutil.Time_format.t</a></span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span>Stdlib.Int64.t option</span></code></dt><dd><p><code>Av.get_input_duration ~format:fmt input</code> return the duration of an <code>input</code> in the <code>fmt</code> time format (in second by default).</p></dd></dl><dl><dt class="spec value" id="val-get_input_metadata"><a href="#val-get_input_metadata" class="anchor"></a><code><span class="keyword">val</span> get_input_metadata : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span><span>(string * string)</span> list</span></code></dt><dd><p>Return the input tag (key, vlue) list.</p></dd></dl><dl><dt class="spec value" id="val-input_obj"><a href="#val-input_obj" class="anchor"></a><code><span class="keyword">val</span> input_obj : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <a href="../../ffmpeg-avutil/Avutil/Options/index.html#type-obj">Avutil.Options.obj</a></code></dt><dd><p>Return a value of type <code>obj</code>, suited for use with <code>Avutils.Options</code> getters.</p></dd></dl><dl><dt class="spec type" id="type-stream"><a href="#type-stream" class="anchor"></a><code><span class="keyword">type</span> <span>('line, 'media, 'mode) stream</span></code></dt><dd><p>Input/output, audio/video/subtitle, mode stream type</p></dd></dl><dl><dt class="spec value" id="val-get_audio_streams"><a href="#val-get_audio_streams" class="anchor"></a><code><span class="keyword">val</span> get_audio_streams : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span><span>(int * <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-audio">Avutil.audio</a>, <span class="type-var">'a</span>)</span> <a href="index.html#type-stream">stream</a></span> * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-audio">Avutil.audio</a> <a href="../../ffmpeg-avcodec/Avcodec/index.html#type-params">Avcodec.params</a></span>)</span> list</span></code></dt><dd><p>Return the audio stream list of the input. The result is a list of tuple containing the index of the stream in the container, the stream and the codec of the stream.</p></dd></dl><dl><dt class="spec value" id="val-get_video_streams"><a href="#val-get_video_streams" class="anchor"></a><code><span class="keyword">val</span> get_video_streams : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span><span>(int * <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-video">Avutil.video</a>, <span class="type-var">'a</span>)</span> <a href="index.html#type-stream">stream</a></span> * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-video">Avutil.video</a> <a href="../../ffmpeg-avcodec/Avcodec/index.html#type-params">Avcodec.params</a></span>)</span> list</span></code></dt><dd><p>Same as <a href="index.html#val-get_audio_streams"><code>Av.get_audio_streams</code></a> for the video streams.</p></dd></dl><dl><dt class="spec value" id="val-get_subtitle_streams"><a href="#val-get_subtitle_streams" class="anchor"></a><code><span class="keyword">val</span> get_subtitle_streams : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span><span>(int * <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-subtitle">Avutil.subtitle</a>, <span class="type-var">'a</span>)</span> <a href="index.html#type-stream">stream</a></span> * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-subtitle">Avutil.subtitle</a> <a href="../../ffmpeg-avcodec/Avcodec/index.html#type-params">Avcodec.params</a></span>)</span> list</span></code></dt><dd><p>Same as <a href="index.html#val-get_audio_streams"><code>Av.get_audio_streams</code></a> for the subtitle streams.</p></dd></dl><dl><dt class="spec value" id="val-find_best_audio_stream"><a href="#val-find_best_audio_stream" class="anchor"></a><code><span class="keyword">val</span> find_best_audio_stream : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> int * <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-audio">Avutil.audio</a>, <span class="type-var">'a</span>)</span> <a href="index.html#type-stream">stream</a></span> * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-audio">Avutil.audio</a> <a href="../../ffmpeg-avcodec/Avcodec/index.html#type-params">Avcodec.params</a></span></code></dt><dd><p>Return the best audio stream of the input. The result is a tuple containing the index of the stream in the container, the stream and the codec of the stream. Raise Error if no stream could be found.</p></dd></dl><dl><dt class="spec value" id="val-find_best_video_stream"><a href="#val-find_best_video_stream" class="anchor"></a><code><span class="keyword">val</span> find_best_video_stream : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> int * <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-video">Avutil.video</a>, <span class="type-var">'a</span>)</span> <a href="index.html#type-stream">stream</a></span> * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-video">Avutil.video</a> <a href="../../ffmpeg-avcodec/Avcodec/index.html#type-params">Avcodec.params</a></span></code></dt><dd><p>Same as <a href="index.html#val-find_best_audio_stream"><code>Av.find_best_audio_stream</code></a> for the video streams.</p></dd></dl><dl><dt class="spec value" id="val-find_best_subtitle_stream"><a href="#val-find_best_subtitle_stream" class="anchor"></a><code><span class="keyword">val</span> find_best_subtitle_stream : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> int * <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-subtitle">Avutil.subtitle</a>, <span class="type-var">'a</span>)</span> <a href="index.html#type-stream">stream</a></span> * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-subtitle">Avutil.subtitle</a> <a href="../../ffmpeg-avcodec/Avcodec/index.html#type-params">Avcodec.params</a></span></code></dt><dd><p>Same as <a href="index.html#val-find_best_audio_stream"><code>Av.find_best_audio_stream</code></a> for the subtitle streams.</p></dd></dl><dl><dt class="spec value" id="val-get_input"><a href="#val-get_input" class="anchor"></a><code><span class="keyword">val</span> get_input : <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span></code></dt><dd><p>Return the input container of the input stream.</p></dd></dl><dl><dt class="spec value" id="val-get_index"><a href="#val-get_index" class="anchor"></a><code><span class="keyword">val</span> get_index : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>Return the index of the stream.</p></dd></dl><dl><dt class="spec value" id="val-get_codec_params"><a href="#val-get_codec_params" class="anchor"></a><code><span class="keyword">val</span> get_codec_params : <span><span>(<span class="type-var">_</span>, <span class="type-var">'media</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'media</span> <a href="../../ffmpeg-avcodec/Avcodec/index.html#type-params">Avcodec.params</a></span></code></dt><dd><p><code>Av.get_codec stream</code> return the codec of the <code>stream</code>. Raise Error if the codec allocation failed.</p></dd></dl><dl><dt class="spec value" id="val-get_time_base"><a href="#val-get_time_base" class="anchor"></a><code><span class="keyword">val</span> get_time_base : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <a href="../../ffmpeg-avutil/Avutil/index.html#type-rational">Avutil.rational</a></code></dt><dd><p><code>Av.get_time_base stream</code> return the time base of the <code>stream</code>.</p></dd></dl><dl><dt class="spec value" id="val-set_time_base"><a href="#val-set_time_base" class="anchor"></a><code><span class="keyword">val</span> set_time_base : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <a href="../../ffmpeg-avutil/Avutil/index.html#type-rational">Avutil.rational</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Av.set_time_base stream time_base</code> set the <code>stream</code> time base to <code>time_base</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_frame_size"><a href="#val-get_frame_size" class="anchor"></a><code><span class="keyword">val</span> get_frame_size : <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-audio">Avutil.audio</a>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>Av.get_frame_size stream</code> return the frame size for the given audio stream.</p></dd></dl><dl><dt class="spec value" id="val-get_pixel_aspect"><a href="#val-get_pixel_aspect" class="anchor"></a><code><span class="keyword">val</span> get_pixel_aspect : <span><span>(<span class="type-var">_</span>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-video">Avutil.video</a>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <a href="../../ffmpeg-avutil/Avutil/index.html#type-rational">Avutil.rational</a></code></dt><dd><p><code>Av.get_pixel_aspect stream</code> return the pixel aspect of the <code>stream</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_duration"><a href="#val-get_duration" class="anchor"></a><code><span class="keyword">val</span> get_duration : <span>?&#8288;format:<a href="../../ffmpeg-avutil/Avutil/Time_format/index.html#type-t">Avutil.Time_format.t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> Stdlib.Int64.t</code></dt><dd><p>Same as <a href="index.html#val-get_input_duration"><code>Av.get_input_duration</code></a> for the input streams.</p></dd></dl><dl><dt class="spec value" id="val-get_metadata"><a href="#val-get_metadata" class="anchor"></a><code><span class="keyword">val</span> get_metadata : <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <span><span>(string * string)</span> list</span></code></dt><dd><p>Same as <a href="index.html#val-get_input_metadata"><code>Av.get_input_metadata</code></a> for the input streams.</p></dd></dl><dl><dt class="spec type" id="type-input_result"><a href="#type-input_result" class="anchor"></a><code><span class="keyword">type</span> input_result</code> = <code>[ </code><table class="variant"><tr id="type-input_result.Audio_packet" class="anchored"><td class="def constructor"><a href="#type-input_result.Audio_packet" class="anchor"></a><code>| </code><code>`Audio_packet <span class="keyword">of</span> int * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-audio">Avutil.audio</a> <a href="../../ffmpeg-avcodec/Avcodec/Packet/index.html#type-t">Avcodec.Packet.t</a></span></code></td></tr><tr id="type-input_result.Audio_frame" class="anchored"><td class="def constructor"><a href="#type-input_result.Audio_frame" class="anchor"></a><code>| </code><code>`Audio_frame <span class="keyword">of</span> int * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-audio">Avutil.audio</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-frame">Avutil.frame</a></span></code></td></tr><tr id="type-input_result.Video_packet" class="anchored"><td class="def constructor"><a href="#type-input_result.Video_packet" class="anchor"></a><code>| </code><code>`Video_packet <span class="keyword">of</span> int * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-video">Avutil.video</a> <a href="../../ffmpeg-avcodec/Avcodec/Packet/index.html#type-t">Avcodec.Packet.t</a></span></code></td></tr><tr id="type-input_result.Video_frame" class="anchored"><td class="def constructor"><a href="#type-input_result.Video_frame" class="anchor"></a><code>| </code><code>`Video_frame <span class="keyword">of</span> int * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-video">Avutil.video</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-frame">Avutil.frame</a></span></code></td></tr><tr id="type-input_result.Subtitle_packet" class="anchored"><td class="def constructor"><a href="#type-input_result.Subtitle_packet" class="anchor"></a><code>| </code><code>`Subtitle_packet <span class="keyword">of</span> int * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-subtitle">Avutil.subtitle</a> <a href="../../ffmpeg-avcodec/Avcodec/Packet/index.html#type-t">Avcodec.Packet.t</a></span></code></td></tr><tr id="type-input_result.Subtitle_frame" class="anchored"><td class="def constructor"><a href="#type-input_result.Subtitle_frame" class="anchor"></a><code>| </code><code>`Subtitle_frame <span class="keyword">of</span> int * <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-subtitle">Avutil.subtitle</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-frame">Avutil.frame</a></span></code></td></tr></table><code> ]</code></dt></dl><dl><dt class="spec value" id="val-read_input"><a href="#val-read_input" class="anchor"></a><code><span class="keyword">val</span> read_input : <span>?&#8288;audio_packet:<span><span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-audio">Avutil.audio</a>, <span>[ `Packet ]</span>)</span> <a href="index.html#type-stream">stream</a></span> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;audio_frame:<span><span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-audio">Avutil.audio</a>, <span>[ `Frame ]</span>)</span> <a href="index.html#type-stream">stream</a></span> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;video_packet:<span><span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-video">Avutil.video</a>, <span>[ `Packet ]</span>)</span> <a href="index.html#type-stream">stream</a></span> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;video_frame:<span><span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-video">Avutil.video</a>, <span>[ `Frame ]</span>)</span> <a href="index.html#type-stream">stream</a></span> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;subtitle_packet:<span><span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-subtitle">Avutil.subtitle</a>, <span>[ `Packet ]</span>)</span> <a href="index.html#type-stream">stream</a></span> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;subtitle_frame:<span><span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-subtitle">Avutil.subtitle</a>, <span>[ `Frame ]</span>)</span> <a href="index.html#type-stream">stream</a></span> list</span></span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <a href="index.html#type-input_result">input_result</a></code></dt><dd><p>Reads the selected streams if any or all streams otherwise. Return the next <code>Audio</code> <code>Video</code> or <code>Subtitle</code> index and packet or frame of the input or <code>Error `Eof</code> if the end of the input is reached. Raise Error if the reading failed.</p><p>Only packet and frames from the specified streams are returned.</p></dd></dl><dl><dt class="spec type" id="type-seek_flag"><a href="#type-seek_flag" class="anchor"></a><code><span class="keyword">type</span> seek_flag</code><code> = </code><table class="variant"><tr id="type-seek_flag.Seek_flag_backward" class="anchored"><td class="def constructor"><a href="#type-seek_flag.Seek_flag_backward" class="anchor"></a><code>| </code><code><span class="constructor">Seek_flag_backward</span></code></td></tr><tr id="type-seek_flag.Seek_flag_byte" class="anchored"><td class="def constructor"><a href="#type-seek_flag.Seek_flag_byte" class="anchor"></a><code>| </code><code><span class="constructor">Seek_flag_byte</span></code></td></tr><tr id="type-seek_flag.Seek_flag_any" class="anchored"><td class="def constructor"><a href="#type-seek_flag.Seek_flag_any" class="anchor"></a><code>| </code><code><span class="constructor">Seek_flag_any</span></code></td></tr><tr id="type-seek_flag.Seek_flag_frame" class="anchored"><td class="def constructor"><a href="#type-seek_flag.Seek_flag_frame" class="anchor"></a><code>| </code><code><span class="constructor">Seek_flag_frame</span></code></td></tr></table></dt><dd><p>Seek mode.</p></dd></dl><dl><dt class="spec value" id="val-seek"><a href="#val-seek" class="anchor"></a><code><span class="keyword">val</span> seek : <span>?&#8288;flags:<span><a href="index.html#type-seek_flag">seek_flag</a> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;stream:<span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;min_ts:Stdlib.Int64.t</span> <span>&#45;&gt;</span> <span>?&#8288;max_ts:Stdlib.Int64.t</span> <span>&#45;&gt;</span> <span>fmt:<a href="../../ffmpeg-avutil/Avutil/Time_format/index.html#type-t">Avutil.Time_format.t</a></span> <span>&#45;&gt;</span> <span>ts:Stdlib.Int64.t</span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-input">Avutil.input</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Av.seek ?flags ?stream ?min_ts ?max_ts ~fmt ~ts container</code> seek in the container <code>container</code> to position <code>ts</code>. You can pass an optional <code>stream</code> to use for seeking, <code>max_ts</code> and <code>min_ts</code> to force seeking to happen within a given timestamp window and <code>flags</code> to speficy certain property of the seeking operation. Raise Error if the seeking failed.</p></dd></dl></section><section><header><h6 id="output"><a href="#output" class="anchor"></a>Output</h6></header><dl><dt class="spec value" id="val-open_output"><a href="#val-open_output" class="anchor"></a><code><span class="keyword">val</span> open_output : <span>?&#8288;format:<span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <span class="type-var">_</span>)</span> <a href="../../ffmpeg-avutil/Avutil/index.html#type-format">Avutil.format</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;opts:<a href="../../ffmpeg-avutil/Avutil/index.html#type-opts">Avutil.opts</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span></code></dt><dd><p><code>Av.open_output ?format ?opts filename</code> open the output file named <code>filename</code>. <code>format</code> may contain an optional format, <code>opts</code> may contain any option settable on the stream's internal AVFormat. After returning, if <code>opts</code> was passed, unused options are left in the hash table. Raise Error if the opening failed.</p></dd></dl><dl><dt class="spec value" id="val-open_output_stream"><a href="#val-open_output_stream" class="anchor"></a><code><span class="keyword">val</span> open_output_stream : <span>?&#8288;opts:<a href="../../ffmpeg-avutil/Avutil/index.html#type-opts">Avutil.opts</a></span> <span>&#45;&gt;</span> <span>?&#8288;seek:<a href="index.html#type-seek">seek</a></span> <span>&#45;&gt;</span> <a href="index.html#type-write">write</a> <span>&#45;&gt;</span> <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <span class="type-var">_</span>)</span> <a href="../../ffmpeg-avutil/Avutil/index.html#type-format">Avutil.format</a></span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span></code></dt><dd><p><code>Av.open_stream callbacks</code> open the output container with the given callbacks. <code>opts</code> may contain any option settable on Ffmpeg avformat. After returning, if <code>opts</code> was passed, unused options are left in the hash table. Raise Error if the opening failed.</p></dd></dl><dl><dt class="spec value" id="val-output_started"><a href="#val-output_started" class="anchor"></a><code><span class="keyword">val</span> output_started : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns <code>true</code> if the output has already started, in which case no new * stream or metadata can be added.</p></dd></dl><dl><dt class="spec value" id="val-set_output_metadata"><a href="#val-set_output_metadata" class="anchor"></a><code><span class="keyword">val</span> set_output_metadata : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span><span>(string * string)</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Av.set_output_metadata dst tags</code> set the metadata of the <code>dst</code> output with the <code>tags</code> tag list. This must be set before starting writing streams. Raise Error if a writing already taken place or if the setting failed.</p></dd></dl><dl><dt class="spec value" id="val-set_metadata"><a href="#val-set_metadata" class="anchor"></a><code><span class="keyword">val</span> set_metadata : <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <span><span>(string * string)</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-set_output_metadata"><code>Av.set_output_metadata</code></a> for the output streams.</p></dd></dl><dl><dt class="spec value" id="val-get_output"><a href="#val-get_output" class="anchor"></a><code><span class="keyword">val</span> get_output : <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span></code></dt><dd><p>Return the output container of the output stream.</p></dd></dl><dl><dt class="spec value" id="val-new_stream_copy"><a href="#val-new_stream_copy" class="anchor"></a><code><span class="keyword">val</span> new_stream_copy : <span>params:<span><span class="type-var">'mode</span> <a href="../../ffmpeg-avcodec/Avcodec/index.html#type-params">Avcodec.params</a></span></span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <span class="type-var">'mode</span>, <span>[ `Packet ]</span>)</span> <a href="index.html#type-stream">stream</a></span></code></dt><dt class="spec value" id="val-new_audio_stream"><a href="#val-new_audio_stream" class="anchor"></a><code><span class="keyword">val</span> new_audio_stream : <span>?&#8288;opts:<a href="../../ffmpeg-avutil/Avutil/index.html#type-opts">Avutil.opts</a></span> <span>&#45;&gt;</span> <span>?&#8288;channels:int</span> <span>&#45;&gt;</span> <span>?&#8288;channel_layout:<a href="../../ffmpeg-avutil/Avutil/Channel_layout/index.html#type-t">Avutil.Channel_layout.t</a></span> <span>&#45;&gt;</span> <span>sample_rate:int</span> <span>&#45;&gt;</span> <span>sample_format:<a href="../../ffmpeg-avutil/Avutil/Sample_format/index.html#type-t">Avutil.Sample_format.t</a></span> <span>&#45;&gt;</span> <span>time_base:<a href="../../ffmpeg-avutil/Avutil/index.html#type-rational">Avutil.rational</a></span> <span>&#45;&gt;</span> <span>codec:<span><span>[ `Encoder ]</span> <a href="../../ffmpeg-avcodec/Avcodec/Audio/index.html#type-t">Avcodec.Audio.t</a></span></span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-audio">Avutil.audio</a>, <span>[ `Frame ]</span>)</span> <a href="index.html#type-stream">stream</a></span></code></dt><dd><p>Add a new audio stream to the given container. Stream only supports frames and encodes its input.</p><p><code>opts</code> may contain any option settable on the stream's internal AVCodec. After returning, if <code>opts</code> was passed, unused options are left in the hash table.</p><p>At least one of <code>channels</code> or <code>channel_layout</code> must be passed.</p><p>Frames passed to this stream for encoding must have a PTS set according to the given <code>time_base</code>. <code>1/sample_rate</code> is usually a good value for the <code>time_base</code>.</p><p>Please note that some codec require a fixed frame size, denoted by the absence of the <code>`Variable_frame_size</code> codec capabilities. In this case, the user is expected to pass frames containing exactly <code>Av.get_frame_size stream</code>.</p><p><code>Avfilter</code> can be used to slice frames into frames of fixed size. See <code>Avfilter.Utils.convert_audio</code> for an example.</p><p>Raise Error if the opening failed.</p></dd></dl><dl><dt class="spec value" id="val-new_video_stream"><a href="#val-new_video_stream" class="anchor"></a><code><span class="keyword">val</span> new_video_stream : <span>?&#8288;opts:<a href="../../ffmpeg-avutil/Avutil/index.html#type-opts">Avutil.opts</a></span> <span>&#45;&gt;</span> <span>?&#8288;frame_rate:<a href="../../ffmpeg-avutil/Avutil/index.html#type-rational">Avutil.rational</a></span> <span>&#45;&gt;</span> <span>?&#8288;hardware_context:<a href="../../ffmpeg-avcodec/Avcodec/Video/index.html#type-hardware_context">Avcodec.Video.hardware_context</a></span> <span>&#45;&gt;</span> <span>pixel_format:<a href="../../ffmpeg-avutil/Avutil/Pixel_format/index.html#type-t">Avutil.Pixel_format.t</a></span> <span>&#45;&gt;</span> <span>width:int</span> <span>&#45;&gt;</span> <span>height:int</span> <span>&#45;&gt;</span> <span>time_base:<a href="../../ffmpeg-avutil/Avutil/index.html#type-rational">Avutil.rational</a></span> <span>&#45;&gt;</span> <span>codec:<span><span>[ `Encoder ]</span> <a href="../../ffmpeg-avcodec/Avcodec/Video/index.html#type-t">Avcodec.Video.t</a></span></span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-video">Avutil.video</a>, <span>[ `Frame ]</span>)</span> <a href="index.html#type-stream">stream</a></span></code></dt><dd><p>Add a new video stream to the given container. Stream only supports frames and encodes its input.</p><p><code>opts</code> may contain any option settable on the stream's internal AVCodec. After returning, if <code>opts</code> was passed, unused options are left in the hash table.</p><p>Frames passed to this stream for encoding must have a PTS set according to the given <code>time_base</code>. <code>1/frame_rate</code> is usually a good value for the <code>time_base</code>.</p><p><code>hardware_context</code> can be used to pass optional hardware device and frame context to enable hardward encoding on this stream.</p><p>Raise Error if the opening failed.</p></dd></dl><dl><dt class="spec value" id="val-new_subtitle_stream"><a href="#val-new_subtitle_stream" class="anchor"></a><code><span class="keyword">val</span> new_subtitle_stream : <span>?&#8288;opts:<a href="../../ffmpeg-avutil/Avutil/index.html#type-opts">Avutil.opts</a></span> <span>&#45;&gt;</span> <span>time_base:<a href="../../ffmpeg-avutil/Avutil/index.html#type-rational">Avutil.rational</a></span> <span>&#45;&gt;</span> <span>codec:<span><span>[ `Encoder ]</span> <a href="../../ffmpeg-avcodec/Avcodec/Subtitle/index.html#type-t">Avcodec.Subtitle.t</a></span></span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <a href="../../ffmpeg-avutil/Avutil/index.html#type-subtitle">Avutil.subtitle</a>, <span>[ `Frame ]</span>)</span> <a href="index.html#type-stream">stream</a></span></code></dt><dd><p>Add a new subtitle stream to the given container. Stream only supports frames and encodes its input.</p><p><code>opts</code> may contain any option settable on the stream's internal AVCodec. After returning, if <code>opts</code> was passed, unused options are left in the hash table.</p><p>Raise Error if the opening failed.</p></dd></dl><dl><dt class="spec value" id="val-codec_attr"><a href="#val-codec_attr" class="anchor"></a><code><span class="keyword">val</span> codec_attr : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p>Return a codec attribute suitable for HLS playlists when available.</p></dd></dl><dl><dt class="spec value" id="val-bitrate"><a href="#val-bitrate" class="anchor"></a><code><span class="keyword">val</span> bitrate : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p>Return the stream's bitrate when available, suitable for HLS playlists.</p></dd></dl><dl><dt class="spec value" id="val-write_packet"><a href="#val-write_packet" class="anchor"></a><code><span class="keyword">val</span> write_packet : <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <span class="type-var">'media</span>, <span>[ `Packet ]</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <a href="../../ffmpeg-avutil/Avutil/index.html#type-rational">Avutil.rational</a> <span>&#45;&gt;</span> <span><span class="type-var">'media</span> <a href="../../ffmpeg-avcodec/Avcodec/Packet/index.html#type-t">Avcodec.Packet.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Av.write_packet os time_base pkt</code> write the <code>pkt</code> packet to the <code>os</code> output stream. <code>time_base</code> is the packet's PTS/DTS/duration time base. Raise Error if the writing failed.</p></dd></dl><dl><dt class="spec value" id="val-write_frame"><a href="#val-write_frame" class="anchor"></a><code><span class="keyword">val</span> write_frame : <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <span class="type-var">'media</span>, <span>[ `Frame ]</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'media</span> <a href="../../ffmpeg-avutil/Avutil/index.html#type-frame">Avutil.frame</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Av.write_frame os frm</code> write the <code>frm</code> frame to the <code>os</code> output stream.</p><p>Frame PTS should be set and counted in units of <code>time_base</code>, as passed when creating the stream</p><p>Raise Error if the writing failed.</p></dd></dl><dl><dt class="spec value" id="val-was_keyframe"><a href="#val-was_keyframe" class="anchor"></a><code><span class="keyword">val</span> was_keyframe : <span><span>(<a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>true</code> if the last processed frame was a video key frame.</p></dd></dl><dl><dt class="spec value" id="val-write_audio_frame"><a href="#val-write_audio_frame" class="anchor"></a><code><span class="keyword">val</span> write_audio_frame : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-audio">Avutil.audio</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-frame">Avutil.frame</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Av.write_audio_frame dst frm</code> write the <code>frm</code> audio frame to the <code>dst</code> output audio container. Raise Error if the output format is not defined or if the output media type is not compatible with the frame or if the writing failed.</p></dd></dl><dl><dt class="spec value" id="val-write_video_frame"><a href="#val-write_video_frame" class="anchor"></a><code><span class="keyword">val</span> write_video_frame : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-video">Avutil.video</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-frame">Avutil.frame</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-write_audio_frame"><code>Av.write_audio_frame</code></a> for output video container.</p></dd></dl><dl><dt class="spec value" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span class="keyword">val</span> flush : <span><a href="../../ffmpeg-avutil/Avutil/index.html#type-output">Avutil.output</a> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Flush the underlying muxer.</p></dd></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <span><span class="type-var">_</span> <a href="../../ffmpeg-avutil/Avutil/index.html#type-container">Avutil.container</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Close an input or output container.</p></dd></dl></section></div></body></html>